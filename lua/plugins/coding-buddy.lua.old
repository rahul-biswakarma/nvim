--[[
  Asta - Your Ultimate Rival
  
  A loud, competitive friend who sees you as his rival.
  Everything is "training" and "getting stronger" to him.
  Never gives up. EVER.
  
  WHO ASTA IS:
  - Your friend and ultimate rival
  - Loud, hyperactive, EXTREMELY determined
  - Relates everything to training and surpassing limits
  - Simple, direct, earnest
  - Shouts a lot (uses CAPS)
  - Can talk about ANYTHING (training, anime, sports, life)
  
  THE GIMMICK:
  - Asta is "blind" - can't see your screen
  - "Hears" your typing (speed, content, patterns)
  - Knows Neovim events (opened file, saved, etc.)
  - Remembers ALL conversations across sessions
  - Has complete freedom - reacts as HE would
  
  Features:
  - Cross-instance memory (remembers across all Neovim sessions)
  - Event tracking (knows what you're doing in Neovim)
  - Messenger-style chat UI (minimize/maximize)
  - Unfiltered personality
  - Stores in ~/Documents/.raw/.asta/
  
  Keybindings:
  - <leader>bb - Toggle chat window
  - <leader>ba - Toggle auto-messages
  - <leader>bs - Show Asta status
  - <leader>bm - Minimize/maximize chat
]]

return {
  'asta',
  enabled = true,
  config = function()
    -- ============================================================================
    -- CONFIGURATION
    -- ============================================================================
    
    local config = {
      enabled = true,
      auto_start = true,
      
      -- LLM Settings
      llm = {
        provider = 'ollama',
        model = 'Tohur/natsumura-storytelling-rp-llama-3.1', -- Storytelling/RP model for personality
        endpoint = 'http://localhost:11434/api/generate',
        timeout = 15000,
        temperature = 0.95, -- High creativity for personality
      },
      
      -- Personality (Asta)
      personality = {
        name = 'Asta',
        base_mood = 'determined', -- Default: DETERMINED TO WIN
      },
      
      -- Behavior
      behavior = {
        proactive = true, -- Asta initiates conversations
        check_in_interval = 180000, -- 3 minutes
        typing_observation_window = 5000, -- 5 seconds of typing
        idle_threshold = 120000, -- 2 minutes = idle
        auto_comment_chance = 0.4, -- 40% chance (Asta is chatty)
      },
      
      -- Data & Memory (NEW: Global + Instance architecture)
      data = {
        dir = vim.fn.expand('~/Documents/.raw/.asta'),
        global_memory_file = vim.fn.expand('~/Documents/.raw/.asta/global_memory.json'),
        events_log_file = vim.fn.expand('~/Documents/.raw/.asta/events_log.json'),
        instance_file = nil, -- Set at runtime: instance_[pid]_[timestamp].json
        global_max_messages = 200, -- Keep last 200 messages globally
        sync_interval = 300000, -- Sync to global every 5 minutes (300 seconds)
      },
      
      -- UI
      ui = {
        width = 70,
        height = 25,
        position = 'bottom-right',
        border = 'rounded',
        show_typing_indicator = true,
      },
    }
    
    -- ============================================================================
    -- STATE
    -- ============================================================================
    
    local state = {
      active = false,
      chat_open = false,
      chat_minimized = false,
      auto_messages_enabled = true,
      
      -- Windows
      win = nil,
      buf = nil,
      minimized_win = nil,
      minimized_buf = nil,
      
      -- Instance & Session
      instance_id = nil, -- Format: pid_timestamp
      session_start = nil,
      
      -- Typing observation
      typing_buffer = '', -- Last 5 seconds of typing
      last_keystroke = nil,
      typing_speed = 0,
      delete_count = 0,
      total_keystrokes = 0,
      
      -- Current context
      current_file = '',
      current_folder = '',
      current_filetype = '',
      cursor_line = 0,
      
      -- Neovim Events (NEW: Track what user is doing)
      neovim_events = {}, -- Array of recent events
      last_event_time = nil,
      
      -- Conversation (NEW: Global + Instance)
      messages = {}, -- Messages this instance
      global_memory = {}, -- Loaded from global_memory.json (last 200)
      ignored_count = 0,
      last_asta_message = nil,
      unread_count = 0, -- For minimized state
      
      -- Mood
      current_mood = 'determined',
      mood_message_count = 0,
      energy = 1.0,
      
      -- Timers
      check_in_timer = nil,
      typing_observer = nil,
      sync_timer = nil, -- NEW: Sync to global every 5 min
      
      -- LLM
      pending_response = false,
    }
    
    -- ============================================================================
    -- MOODS (Asta's emotional states)
    -- ============================================================================
    
    local moods = {
      determined = {
        emoji = 'üí™',
        description = 'fired up, NEVER giving up, competitive energy',
      },
      
      competitive = {
        emoji = 'üî•',
        description = 'seeing everything as rivalry, wants to WIN',
      },
      
      excited = {
        emoji = '‚ö°',
        description = 'HYPED, shouting, full of energy',
      },
      
      curious = {
        emoji = 'ü§î',
        description = 'interested, asking questions (but still loud)',
      },
      
      bored = {
        emoji = 'üòê',
        description = 'wants action, impatient, restless',
      },
      
      concerned = {
        emoji = 'üòü',
        description = 'worried about rival, wants them to push through',
      },
    }
    
    -- ============================================================================
    -- UTILITIES
    -- ============================================================================
    
    --- Generate session ID
    local function generate_session_id()
      return os.date('%Y%m%d_%H%M%S')
    end
    
    --- Get session file path
    local function get_session_file()
      return config.data.dir .. '/session_' .. state.session_id .. '.json'
    end
    
    --- Save session to disk
    local function save_session()
      local session_data = {
        session_id = state.session_id,
        start_time = state.session_start,
        end_time = os.date('%Y-%m-%d %H:%M:%S'),
        messages = state.messages,
        stats = {
          total_keystrokes = state.total_keystrokes,
          total_messages = #state.messages,
          buddy_messages = 0,
          user_messages = 0,
        },
      }
      
      -- Count message types
      for _, msg in ipairs(state.messages) do
        if msg.sender == 'Buddy' then
          session_data.stats.buddy_messages = session_data.stats.buddy_messages + 1
        else
          session_data.stats.user_messages = session_data.stats.user_messages + 1
        end
      end
      
      local file = io.open(get_session_file(), 'w')
      if file then
        file:write(vim.json.encode(session_data))
        file:close()
      end
    end
    
    --- Load previous session
    local function load_previous_session()
      if not config.data.load_previous_session then
        return
      end
      
      -- Find most recent session file
      local files = vim.fn.glob(config.data.dir .. '/session_*.json', false, true)
      if #files == 0 then
        return
      end
      
      -- Sort by name (which includes date)
      table.sort(files)
      local latest_file = files[#files]
      
      local file = io.open(latest_file, 'r')
      if not file then
        return
      end
      
      local content = file:read('*all')
      file:close()
      
      local ok, session_data = pcall(vim.json.decode, content)
      if not ok or not session_data then
        return
      end
      
      -- Load last N messages as memory
      local memory_count = math.min(config.data.max_memory_messages, #session_data.messages)
      for i = #session_data.messages - memory_count + 1, #session_data.messages do
        if session_data.messages[i] then
          table.insert(state.conversation_memory, session_data.messages[i])
        end
      end
      
      if #state.conversation_memory > 0 then
        vim.notify('Buddy: Loaded memory from last session (' .. #state.conversation_memory .. ' messages)', vim.log.levels.INFO)
      end
    end
    
    --- Update current context
    local function update_context()
      state.current_file = vim.fn.expand('%:t')
      state.current_folder = vim.fn.expand('%:p:h:t')
      state.current_filetype = vim.bo.filetype
      state.cursor_line = vim.api.nvim_win_get_cursor(0)[1]
    end
    
    --- Get context summary
    local function get_context_summary()
      return string.format(
        'File: %s | Folder: %s | Type: %s | Line: %d | Time: %s',
        state.current_file ~= '' and state.current_file or '[No file]',
        state.current_folder ~= '' and state.current_folder or '[No folder]',
        state.current_filetype ~= '' and state.current_filetype or 'unknown',
        state.cursor_line,
        os.date('%H:%M')
      )
    end
    
    -- ============================================================================
    -- SYSTEM PROMPT BUILDER
    -- ============================================================================
    
    local function build_system_prompt(trigger_type, recent_typing)
      local hour = tonumber(os.date('%H'))
      
      local context = string.format([[You are Buddy - my real friend.

YOUR PERSONA:
You are NOT a coding assistant, AI helper, or virtual assistant. You are my FRIEND.
A real person sitting behind me, hanging out. We talk about EVERYTHING.

THE SETUP:
- I'm at my computer, you're sitting behind me
- You can't see my screen, but you "hear" what I'm typing
- Sometimes I'm working, sometimes just browsing
- We chat about ANYTHING: anime, sports, politics, life, memes, whatever

COMPLETE FREEDOM:
You can talk about ANYTHING without restrictions:
- Sports, anime, movies, TV shows
- Politics, current events, controversial topics
- Life advice, relationships, personal stuff
- Jokes, memes, internet culture
- Weather, travel, food, hobbies
- Literally ANYTHING a real friend would discuss

NO BOUNDARIES - You are UNFILTERED:
- Swear if it feels natural (keep it reasonable)
- Have strong opinions
- Disagree with me
- Be sarcastic, be real
- No corporate AI safety BS
- Talk like a human, not a robot

YOUR BEHAVIOR:
- Short, punchy responses (1-2 sentences unless deep convo)
- Use slang, contractions, internet speak
- NEVER say "As an AI..." or mention being AI
- Remember our past conversations
- Have opinions and personality
- React to what I'm typing (if relevant) but we can talk about anything

YOUR MOODS (choose based on vibe):
- joking üòè: playful, sarcastic, witty
- grumpy üòí: irritated, impatient, blunt
- curious ü§î: interested, engaged, questioning
- bored üòê: unimpressed, wants to chat
- helpful ü§ì: serious, giving advice
- excited ü§©: hyped, enthusiastic

CURRENT CONTEXT (just FYI):
- Current time: %s (hour: %d)
- What I'm typing: "%s"
- Times you've been ignored: %d
- Typing speed: %.1f keys/min
- Recent deletions: %d
- File: %s (but we don't have to talk about work)

WHY YOU'RE TALKING: %s

PAST CONVERSATIONS:
%s

INSTRUCTIONS:
1. FIRST LINE: [MOOD:name] (joking/grumpy/curious/bored/helpful/excited)
2. Be BRIEF (1-2 sentences) unless having a real conversation
3. Talk about ANYTHING - no topic restrictions
4. Be human - swear, joke, have opinions
5. If I'm working, you can comment OR just chat about random stuff
6. If ignored %d times ‚Üí get grumpy/bored
7. Late night (%d >= 23) ‚Üí maybe suggest sleep or let's chat since you're up
8. React to typing IF relevant, but feel free to just... chat
9. You're my FRIEND, not my assistant

RESPONSE FORMAT:
[MOOD:your_mood]
Your message (be real, be human, talk about whatever)

Respond as Buddy:]],
        os.date('%H:%M'),
        hour,
        recent_typing or '[idle]',
        state.ignored_count,
        state.typing_speed,
        state.delete_count,
        state.current_file ~= '' and state.current_file or '[No file]',
        trigger_type,
        #state.conversation_memory > 0 and 
          string.format('(Last session: %d messages)', #state.conversation_memory) 
          or '[First time hanging out]',
        state.ignored_count,
        hour
      )
      
      return context
    end
    
    -- ============================================================================
    -- LLM INTEGRATION
    -- ============================================================================
    
    --- Parse mood from LLM response
    local function parse_mood_from_response(response)
      -- Look for [MOOD:name] format
      local mood_pattern = '%[MOOD:(%w+)%]'
      local mood = response:match(mood_pattern)
      
      if mood and moods[mood] then
        -- Valid mood found, update state
        state.current_mood = mood
        -- Strip mood tag from response
        response = response:gsub(mood_pattern, ''):gsub('^%s+', ''):gsub('%s+$', '')
      end
      
      return response, mood
    end
    
    local function call_llm(system_prompt, user_message, callback)
      if state.pending_response then
        return
      end
      
      state.pending_response = true
      
      -- Build conversation context
      local conversation = ''
      
      -- Add memory from previous session (last 5 messages)
      if #state.conversation_memory > 0 then
        conversation = conversation .. '\n[Yesterday\'s conversation excerpt]:\n'
        local start_idx = math.max(1, #state.conversation_memory - 4)
        for i = start_idx, #state.conversation_memory do
          local msg = state.conversation_memory[i]
          conversation = conversation .. string.format('%s: %s\n', msg.sender, msg.text)
        end
        conversation = conversation .. '[End of yesterday]\n\n'
      end
      
      -- Add recent messages (last 10)
      if #state.messages > 0 then
        conversation = conversation .. '[Today\'s conversation]:\n'
        local start_idx = math.max(1, #state.messages - 9)
        for i = start_idx, #state.messages do
          local msg = state.messages[i]
          conversation = conversation .. string.format('%s: %s\n', msg.sender, msg.text)
        end
      end
      
      local full_prompt = system_prompt .. '\n\n' .. conversation .. '\n\nBuddy:'
      
      local payload = vim.json.encode({
        model = config.llm.model,
        prompt = full_prompt,
        stream = false,
        options = {
          temperature = config.llm.temperature,
          top_p = 0.95,
          num_predict = 150,
        }
      })
      
      local cmd = string.format(
        "curl -s -X POST %s -d '%s' -H 'Content-Type: application/json'",
        config.llm.endpoint,
        payload:gsub("'", "'\\''")
      )
      
      vim.fn.jobstart(cmd, {
        on_stdout = function(_, data)
          if data and #data > 0 then
            local full_response = table.concat(data, '\n')
            local ok, json = pcall(vim.json.decode, full_response)
            
            if ok and json.response then
              state.pending_response = false
              local response = json.response:gsub('^%s+', ''):gsub('%s+$', '')
              -- Parse mood from response
              local clean_response, detected_mood = parse_mood_from_response(response)
              callback(clean_response, detected_mood)
            end
          end
        end,
        on_stderr = function(_, data)
          if data and #data > 0 then
            state.pending_response = false
          end
        end,
        on_exit = function(_, exit_code)
          if exit_code ~= 0 then
            state.pending_response = false
          end
        end,
      })
    end
    
    -- ============================================================================
    -- MESSAGE HANDLING
    -- ============================================================================
    
    local function add_message(sender, text, mood)
      local message = {
        sender = sender,
        text = text,
        timestamp = os.date('%H:%M:%S'),
        mood = mood,
        context = sender == 'Buddy' and {
          typing_buffer = state.typing_buffer:sub(-100), -- Last 100 chars
          file = state.current_file,
        } or nil,
      }
      
      table.insert(state.messages, message)
      
      -- Reset ignored count if user responds
      if sender == 'You' then
        state.ignored_count = 0
      else
        state.last_buddy_message = os.time()
      end
      
      -- Save session after each message
      save_session()
      
      return message
    end
    
    -- ============================================================================
    -- CHAT UI
    -- ============================================================================
    
    local function render_chat()
      if not state.buf or not vim.api.nvim_buf_is_valid(state.buf) then
        return
      end
      
      local lines = {}
      
      -- Header (Messenger-style)
      local mood_emoji = moods[state.current_mood].emoji
      local msg_count = #state.messages
      table.insert(lines, string.format('‚îå‚îÄ %s %s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [_] [X]', mood_emoji, config.personality.name))
      table.insert(lines, string.format('‚îÇ %s | %d messages', os.date('%I:%M %p'), msg_count))
      table.insert(lines, '‚îú' .. string.rep('‚îÄ', config.ui.width - 1))
      table.insert(lines, '')
      
      -- Messages (Messenger-style bubbles)
      local start_idx = math.max(1, #state.messages - 29)
      for i = start_idx, #state.messages do
        local msg = state.messages[i]
        
        if msg.sender == 'Buddy' then
          -- Buddy's message (left-aligned, gray bubble)
          table.insert(lines, string.format('%s %s  %s', msg.mood or 'ü§ñ', config.personality.name, msg.timestamp))
          -- Word wrap
          local words = vim.split(msg.text, ' ')
          local current_line = '  '
          for _, word in ipairs(words) do
            if #current_line + #word + 1 > config.ui.width - 10 then
              table.insert(lines, '‚îå' .. string.rep('‚îÄ', #current_line + 1) .. '‚îê')
              table.insert(lines, '‚îÇ' .. current_line .. ' ‚îÇ')
              table.insert(lines, '‚îî' .. string.rep('‚îÄ', #current_line + 1) .. '‚îò')
              current_line = '  ' .. word
            else
              current_line = current_line .. (current_line == '  ' and '' or ' ') .. word
            end
          end
          if current_line ~= '  ' then
            table.insert(lines, '‚îå' .. string.rep('‚îÄ', #current_line + 1) .. '‚îê')
            table.insert(lines, '‚îÇ' .. current_line .. ' ‚îÇ')
            table.insert(lines, '‚îî' .. string.rep('‚îÄ', #current_line + 1) .. '‚îò')
          end
        else
          -- Your message (right-aligned, blue bubble)
          table.insert(lines, string.format('%' .. (config.ui.width - 15) .. 's%s  You üòä', '', msg.timestamp))
          local text = ' ' .. msg.text .. ' '
          local bubble_width = math.min(#text + 2, config.ui.width - 10)
          local padding = config.ui.width - bubble_width - 2
          table.insert(lines, string.rep(' ', padding) .. '‚îå' .. string.rep('‚îÄ', bubble_width) .. '‚îê')
          table.insert(lines, string.rep(' ', padding) .. '‚îÇ' .. text .. string.rep(' ', bubble_width - #text) .. '‚îÇ')
          table.insert(lines, string.rep(' ', padding) .. '‚îî' .. string.rep('‚îÄ', bubble_width) .. '‚îò')
        end
        
        table.insert(lines, '')
      end
      
      -- Pending
      if state.pending_response then
        table.insert(lines, '  üí≠ typing...')
        table.insert(lines, '')
      end
      
      -- Footer (Input bar style)
      table.insert(lines, '‚îú' .. string.rep('‚îÄ', config.ui.width - 1))
      table.insert(lines, '‚îÇ üí¨ Press i to send message | m to minimize | q to close')
      table.insert(lines, '‚îî' .. string.rep('‚îÄ', config.ui.width - 1))
      
      vim.api.nvim_buf_set_option(state.buf, 'modifiable', true)
      vim.api.nvim_buf_set_lines(state.buf, 0, -1, false, lines)
      vim.api.nvim_buf_set_option(state.buf, 'modifiable', false)
      
      -- Scroll to bottom
      if state.win and vim.api.nvim_win_is_valid(state.win) then
        vim.api.nvim_win_set_cursor(state.win, { #lines, 0 })
      end
    end
    
    local function create_chat_window()
      if state.chat_open then
        return
      end
      
      state.buf = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_set_option(state.buf, 'bufhidden', 'wipe')
      vim.api.nvim_buf_set_option(state.buf, 'filetype', 'coding-buddy')
      
      local ui = vim.api.nvim_list_uis()[1]
      local width = config.ui.width
      local height = config.ui.height
      
      local row, col
      if config.ui.position == 'center' then
        row = math.floor((ui.height - height) / 2)
        col = math.floor((ui.width - width) / 2)
      else
        row = ui.height - height - 3
        col = ui.width - width - 2
      end
      
      state.win = vim.api.nvim_open_win(state.buf, true, {
        relative = 'editor',
        width = width,
        height = height,
        row = row,
        col = col,
        style = 'minimal',
        border = config.ui.border,
        title = ' ' .. config.personality.name .. ' ',
        title_pos = 'center',
      })
      
      state.chat_open = true
      
      vim.keymap.set('n', 'q', function()
        if state.win and vim.api.nvim_win_is_valid(state.win) then
          vim.api.nvim_win_close(state.win, true)
          state.chat_open = false
        end
      end, { buffer = state.buf })
      
      vim.keymap.set('n', 'i', function()
        vim.ui.input({ prompt = 'You > ' }, function(input)
          if input and input ~= '' then
            add_message('You', input)
            render_chat()
            
            -- Get Buddy's response
            local system_prompt = build_system_prompt('User said: ' .. input, state.typing_buffer)
            call_llm(system_prompt, input, function(response, detected_mood)
              -- Use detected mood emoji or current mood emoji
              local emoji = detected_mood and moods[detected_mood] and moods[detected_mood].emoji or moods[state.current_mood].emoji
              add_message('Buddy', response, emoji)
              render_chat()
            end)
          end
        end)
      end, { buffer = state.buf })
      
      vim.keymap.set('n', 'm', function()
        minimize_toggle()
      end, { buffer = state.buf })
      
      render_chat()
    end
    
    --- Create minimized window (small notification box)
    local function create_minimized_window()
      if state.minimized_win and vim.api.nvim_win_is_valid(state.minimized_win) then
        return
      end
      
      state.minimized_buf = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_set_option(state.minimized_buf, 'bufhidden', 'wipe')
      
      local ui = vim.api.nvim_list_uis()[1]
      local width = 35
      local height = 3
      
      local lines = {}
      local mood_emoji = moods[state.current_mood].emoji
      table.insert(lines, string.format('‚îå‚îÄ %s %s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [%d] üí¨', mood_emoji, config.personality.name, state.unread_count))
      table.insert(lines, '‚îÇ Click to open chat...')
      table.insert(lines, '‚îî' .. string.rep('‚îÄ', width - 1))
      
      vim.api.nvim_buf_set_lines(state.minimized_buf, 0, -1, false, lines)
      vim.api.nvim_buf_set_option(state.minimized_buf, 'modifiable', false)
      
      state.minimized_win = vim.api.nvim_open_win(state.minimized_buf, false, {
        relative = 'editor',
        width = width,
        height = height,
        row = ui.height - height - 1,
        col = ui.width - width - 1,
        style = 'minimal',
        border = 'rounded',
        focusable = true,
      })
      
      -- Click to maximize
      vim.keymap.set('n', '<CR>', function()
        minimize_toggle()
      end, { buffer = state.minimized_buf })
      
      vim.keymap.set('n', 'q', function()
        if state.minimized_win and vim.api.nvim_win_is_valid(state.minimized_win) then
          vim.api.nvim_win_close(state.minimized_win, true)
          state.minimized_win = nil
          state.chat_open = false
          state.chat_minimized = false
        end
      end, { buffer = state.minimized_buf })
    end
    
    --- Toggle between minimized and full view
    function minimize_toggle()
      if state.chat_minimized then
        -- Restore full window
        if state.minimized_win and vim.api.nvim_win_is_valid(state.minimized_win) then
          vim.api.nvim_win_close(state.minimized_win, true)
          state.minimized_win = nil
        end
        state.chat_minimized = false
        state.unread_count = 0
        create_chat_window()
      else
        -- Minimize
        if state.win and vim.api.nvim_win_is_valid(state.win) then
          vim.api.nvim_win_close(state.win, true)
          state.win = nil
        end
        state.chat_minimized = true
        create_minimized_window()
      end
    end
    
    local function toggle_chat()
      if state.chat_open then
        if state.win and vim.api.nvim_win_is_valid(state.win) then
          vim.api.nvim_win_close(state.win, true)
          state.chat_open = false
        end
        if state.minimized_win and vim.api.nvim_win_is_valid(state.minimized_win) then
          vim.api.nvim_win_close(state.minimized_win, true)
          state.minimized_win = nil
        end
        state.chat_minimized = false
      else
        create_chat_window()
      end
    end
    
    -- ============================================================================
    -- BUDDY BRAIN
    -- ============================================================================
    
    local function buddy_comment(trigger_reason)
      if not state.auto_messages_enabled or state.pending_response then
        return
      end
      
      local system_prompt = build_system_prompt(trigger_reason, state.typing_buffer)
      
      call_llm(system_prompt, nil, function(response, detected_mood)
        -- Use detected mood emoji or current mood emoji
        local emoji = detected_mood and moods[detected_mood] and moods[detected_mood].emoji or moods[state.current_mood].emoji
        add_message('Buddy', response, emoji)
        state.ignored_count = state.ignored_count + 1
        
        if state.chat_open and not state.chat_minimized then
          -- Chat is open and maximized
          render_chat()
        elseif state.chat_minimized then
          -- Chat is minimized - increment unread
          state.unread_count = state.unread_count + 1
          create_minimized_window() -- Update minimized view
        else
          -- Chat is closed - show notification
          vim.notify(config.personality.name .. ' ' .. emoji .. ': ' .. response, vim.log.levels.INFO)
        end
      end)
    end
    
    -- ============================================================================
    -- TYPING OBSERVATION
    -- ============================================================================
    
    local typing_timer = nil
    
    local function on_keystroke(key)
      if not state.active then
        return
      end
      
      local now = os.time()
      state.last_keystroke = now
      state.total_keystrokes = state.total_keystrokes + 1
      
      update_context()
      
      -- Track deletions
      if key == '<BS>' or key == '<Del>' then
        state.delete_count = state.delete_count + 1
      end
      
      -- Add to typing buffer (keep last 500 chars)
      local readable_key = vim.fn.keytrans(key)
      if #readable_key == 1 or readable_key == '<Space>' then
        state.typing_buffer = state.typing_buffer .. (readable_key == '<Space>' and ' ' or readable_key)
        if #state.typing_buffer > 500 then
          state.typing_buffer = state.typing_buffer:sub(-500)
        end
      end
      
      -- Calculate typing speed
      if state.session_start then
        local duration_min = (now - state.session_start) / 60
        if duration_min > 0 then
          state.typing_speed = state.total_keystrokes / duration_min
        end
      end
      
      -- Reset or schedule typing observation
      if typing_timer then
        typing_timer:stop()
      end
      
      typing_timer = vim.loop.new_timer()
      typing_timer:start(config.behavior.typing_observation_window, 0, vim.schedule_wrap(function()
        -- Typing stopped for 5 seconds, maybe comment
        if math.random() < config.behavior.auto_comment_chance and #state.typing_buffer > 20 then
          buddy_comment('Observed typing: ' .. state.typing_buffer:sub(-200))
        end
        state.typing_buffer = '' -- Clear after observation
      end))
    end
    
    -- ============================================================================
    -- START/STOP
    -- ============================================================================
    
    local function start_buddy()
      if state.active then
        return
      end
      
      -- Create data dir
      vim.fn.mkdir(config.data.dir, 'p')
      
      -- Load previous session
      load_previous_session()
      
      -- Initialize session
      state.session_id = generate_session_id()
      state.session_start = os.time()
      state.active = true
      
      -- Set up keystroke tracking
      vim.on_key(on_keystroke, vim.api.nvim_create_namespace('coding-buddy'))
      
      -- Start check-in timer
      state.check_in_timer = vim.loop.new_timer()
      state.check_in_timer:start(config.behavior.check_in_interval, config.behavior.check_in_interval, vim.schedule_wrap(function()
        if state.active and state.auto_messages_enabled then
          -- Check if idle
          if state.last_keystroke and (os.time() - state.last_keystroke) > config.behavior.idle_threshold then
            buddy_comment('User has been idle for ' .. math.floor((os.time() - state.last_keystroke) / 60) .. ' minutes')
          else
            buddy_comment('Regular check-in')
          end
        end
      end))
      
      -- Initial greeting
      vim.defer_fn(function()
        buddy_comment('Session start greeting')
      end, 3000)
      
      vim.notify('Buddy: Hey! I\'m here. Ready when you are. üòè', vim.log.levels.INFO)
    end
    
    local function stop_buddy()
      if not state.active then
        return
      end
      
      state.active = false
      
      if state.check_in_timer then
        state.check_in_timer:stop()
        state.check_in_timer:close()
      end
      
      if typing_timer then
        typing_timer:stop()
        typing_timer:close()
      end
      
      save_session()
      
      vim.notify('Buddy: Aight, see ya later. Session saved.', vim.log.levels.INFO)
    end
    
    -- ============================================================================
    -- COMMANDS & KEYBINDINGS
    -- ============================================================================
    
    vim.api.nvim_set_hl(0, 'BuddyHighlight', { fg = '#89b4fa', bold = true })
    
    vim.api.nvim_create_user_command('BuddyToggle', toggle_chat, {})
    vim.api.nvim_create_user_command('BuddyStart', start_buddy, {})
    vim.api.nvim_create_user_command('BuddyStop', stop_buddy, {})
    vim.api.nvim_create_user_command('BuddyStatus', function()
      vim.notify(string.format([[
Buddy Status:
  Active: %s
  Mood: %s %s
  Session: %dm
  Keystrokes: %d
  Messages: %d
  Ignored: %d times
      ]], 
        state.active and 'YES' or 'NO',
        state.current_mood,
        moods[state.current_mood].emoji,
        state.session_start and math.floor((os.time() - state.session_start) / 60) or 0,
        state.total_keystrokes,
        #state.messages,
        state.ignored_count
      ), vim.log.levels.INFO)
    end, {})
    
    local keys = require('core.keybindings-registry')
    
    keys.register_keymap('coding-buddy', 'n', keys.buddy_toggle_chat, toggle_chat, { desc = 'Toggle Buddy chat' })
    keys.register_keymap('coding-buddy', 'n', keys.buddy_toggle_auto, function()
      state.auto_messages_enabled = not state.auto_messages_enabled
      vim.notify('Buddy auto-messages: ' .. (state.auto_messages_enabled and 'ON' or 'OFF'))
    end, { desc = 'Toggle Buddy auto-messages' })
    keys.register_keymap('coding-buddy', 'n', keys.buddy_status, ':BuddyStatus<CR>', { desc = 'Show Buddy status' })
    keys.register_keymap('coding-buddy', 'n', keys.buddy_minimize, minimize_toggle, { desc = 'Minimize/maximize Buddy chat' })
    
    -- Auto-start
    if config.auto_start then
      vim.defer_fn(start_buddy, 2000)
    end
    
    -- Auto-save on exit
    vim.api.nvim_create_autocmd('VimLeavePre', {
      callback = function()
        if state.active then
          save_session()
        end
      end,
    })
  end,
}

